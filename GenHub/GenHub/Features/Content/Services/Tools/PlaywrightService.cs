using System;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using AngleSharp;
using AngleSharp.Dom;
using GenHub.Core.Interfaces.Tools;
using GenHub.Core.Models.Results;
using Microsoft.Extensions.Logging;
using Microsoft.Playwright;

namespace GenHub.Features.Content.Services.Tools;

/// <summary>
/// Service for managing Playwright browser instances and fetching web content.
/// Provides shared browser resources across the application.
/// </summary>
public class PlaywrightService(ILogger<PlaywrightService> logger) : IPlaywrightService, IAsyncDisposable
{
    private static readonly SemaphoreSlim _browserLock = new(1, 1);
    private static readonly TimeSpan DefaultNavigationTimeout = TimeSpan.FromSeconds(30);
    private static readonly TimeSpan DefaultDynamicContentDelay = TimeSpan.FromMilliseconds(500);
    private static readonly TimeSpan AutoDownloadCheckDelay = TimeSpan.FromSeconds(5);
    private static readonly TimeSpan MinimumDownloadTimeout = TimeSpan.FromSeconds(60);

    private static volatile IPlaywright? _playwright;
    private static volatile IBrowser? _browser;

    /// <inheritdoc />
    public async Task<IPage> CreatePageAsync(BrowserNewContextOptions? options = null, CancellationToken cancellationToken = default)
    {
        await EnsurePlaywrightInitializedAsync(logger, cancellationToken);

        if (_browser == null)
        {
            throw new InvalidOperationException("Browser not initialized");
        }

        var contextOptions = options ?? new BrowserNewContextOptions
        {
            UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        };

        var context = await _browser.NewContextAsync(contextOptions);
        return await context.NewPageAsync();
    }

    /// <summary>
    /// Retrieves the rendered HTML content of the page at the specified URL.
    /// </summary>
    /// <param name="url">The absolute URL to navigate to.</param>
    /// <param name="cancellationToken">A token to observe for cancellation requests.</param>
    /// <returns>The page's HTML markup as a string.</returns>
    public async Task<string> FetchHtmlAsync(string url, CancellationToken cancellationToken = default)
    {
        try
        {
            logger.LogDebug("Fetching HTML from {Url}", url);

            var page = await CreatePageAsync(cancellationToken: cancellationToken);
            try
            {
                await page.GotoAsync(url, new PageGotoOptions
                {
                    Timeout = (float)DefaultNavigationTimeout.TotalMilliseconds,
                    WaitUntil = WaitUntilState.DOMContentLoaded,
                });

                // Wait a bit for dynamic content to load
                await Task.Delay(DefaultDynamicContentDelay, cancellationToken);

                return await page.ContentAsync();
            }
            finally
            {
                await page.CloseAsync();
                await page.Context.CloseAsync();
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Failed to fetch HTML from {Url}", url);
            throw;
        }
    }

    /// <inheritdoc />
    public async Task<IDocument> FetchAndParseAsync(string url, CancellationToken cancellationToken = default)
    {
        var html = await FetchHtmlAsync(url, cancellationToken);
        using var browsingContext = BrowsingContext.New(Configuration.Default);
        return await browsingContext.OpenAsync(req => req.Content(html), cancellationToken);
    }

    /// <inheritdoc />
    public async ValueTask DisposeAsync()
    {
        if (_browser != null)
        {
            await _browser.CloseAsync();
            _browser = null;
        }

        if (_playwright != null)
        {
            _playwright.Dispose();
            _playwright = null;
        }

        GC.SuppressFinalize(this);
    }

    /// <summary>
    /// Downloads a file from the specified URL using Playwright and saves it to the configured destination.
    /// </summary>
    /// <param name="configuration">Download settings including the source Url, DestinationPath, Timeout, and OverwriteExisting behavior.</param>
    /// <param name="cancellationToken">Token to cancel the download operation.</param>
    /// <returns>
    /// A <see cref="DownloadResult"/> indicating success with the saved file path, file size, and elapsed time, or a failure result containing an error message.
    /// </returns>
    public async Task<DownloadResult> DownloadFileAsync(GenHub.Core.Models.Common.DownloadConfiguration configuration, CancellationToken cancellationToken = default)
    {
        try
        {
            logger.LogInformation("Starting Playwright download from {Url}", configuration.Url);
            var stopwatch = System.Diagnostics.Stopwatch.StartNew();

            var page = await CreatePageAsync(cancellationToken: cancellationToken);
            var context = page.Context;

            // Use a TaskCompletionSource to capture the download from the context level.
            // This handles cases where the download is triggered in a new tab/popup.
            var downloadTcs = new TaskCompletionSource<IDownload>();

            // Subscribe to the Download event on the page
            void DownloadHandler(object? sender, IDownload download)
            {
                downloadTcs.TrySetResult(download);
            }

            page.Download += DownloadHandler;

            // Also capture downloads from new pages (popups)
            context.Page += (_, newPage) =>
            {
                newPage.Download += DownloadHandler;
            };

            try
            {
                // Trigger the download by navigating to the URL
                await page.GotoAsync(configuration.Url.ToString(), new PageGotoOptions
                {
                    Timeout = (float)configuration.Timeout.TotalMilliseconds,
                    WaitUntil = WaitUntilState.DOMContentLoaded,
                });

                // Race the download TCS against a set delay to check if it auto-started
                // If it doesn't start quickly, we try to click a fallback link
                var waitTask = Task.Delay(AutoDownloadCheckDelay, cancellationToken);
                var completedTask = await Task.WhenAny(downloadTcs.Task, waitTask);

                if (completedTask != downloadTcs.Task)
                {
                    logger.LogInformation("Download did not start automatically within {Seconds}s. Attempting to find fallback link...", AutoDownloadCheckDelay.TotalSeconds);

                    // Try to find a download link
                    var fallbackLink = await page.QuerySelectorAsync("a#download, a.download, a:has-text('Download'), a:has-text('download'), a:has-text('mirror')");

                    if (fallbackLink != null)
                    {
                        var text = await fallbackLink.InnerTextAsync();
                        logger.LogInformation("Found fallback link '{Text}', clicking...", text);
                        try
                        {
                            // Click with a short timeout, just to trigger the action
                            await fallbackLink.ClickAsync(new ElementHandleClickOptions { Timeout = 5000 });
                        }
                        catch (Exception ex)
                        {
                            logger.LogWarning(ex, "Failed to click fallback link. Continuing to wait for download event...");
                        }
                    }
                    else
                    {
                         logger.LogWarning("No fallback download link found. Continuing to wait for download event...");
                    }
                }

                // Wait for the download to start with a generous timeout (60s or config timeout if larger)
                var waitTimeout = TimeSpan.FromMilliseconds(Math.Max(MinimumDownloadTimeout.TotalMilliseconds, configuration.Timeout.TotalMilliseconds));

                // We use WaitAsync (available in .NET 6+) or a custom timeout logic
                var download = await downloadTcs.Task.WaitAsync(waitTimeout, cancellationToken);

                if (download == null)
                {
                    return DownloadResult.CreateFailure("Download failed to initialize (null download object).");
                }

                // Check for download failure state (Major issue)
                var failure = await download.FailureAsync();
                if (!string.IsNullOrEmpty(failure))
                {
                    logger.LogError("Playwright download failed with state: {Failure}", failure);
                    return DownloadResult.CreateFailure($"Download failed: {failure}");
                }

                var path = await download.PathAsync();

                if (File.Exists(configuration.DestinationPath))
                {
                    if (configuration.OverwriteExisting)
                    {
                        File.Delete(configuration.DestinationPath);
                    }
                    else
                    {
                        logger.LogWarning("Destination file {Path} already exists and OverwriteExisting is false. Failing download.", configuration.DestinationPath);
                        return DownloadResult.CreateFailure($"File already exists: {configuration.DestinationPath}");
                    }
                }

                // Create directory if it doesn't exist
                var dir = Path.GetDirectoryName(configuration.DestinationPath);
                if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir))
                {
                    Directory.CreateDirectory(dir);
                }

                // Save to destination
                await download.SaveAsAsync(configuration.DestinationPath);

                var fileInfo = new FileInfo(configuration.DestinationPath);

                logger.LogInformation("Playwright download completed: {Path}, Size: {Size}", configuration.DestinationPath, fileInfo.Length);

                return DownloadResult.CreateSuccess(
                    configuration.DestinationPath,
                    fileInfo.Length,
                    stopwatch.Elapsed,
                    hashVerified: false); // Hash verification typically happens in the service layer if needed
            }
            finally
            {
                // Unsubscribe and close
                page.Download -= DownloadHandler;
                await page.CloseAsync();
                await page.Context.CloseAsync();
            }
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Playwright download failed for {Url}", configuration.Url);
            return DownloadResult.CreateFailure(ex.Message);
        }
    }

    /// <summary>
    /// Ensures a shared Playwright instance and Chromium browser are initialized for use.
    /// </summary>
    /// <remarks>
    /// Acquires an internal semaphore to initialize the singleton Playwright and browser instances in a thread-safe manner; subsequent calls return immediately if initialization is already complete.
    /// </remarks>
    private static async Task EnsurePlaywrightInitializedAsync(ILogger logger, CancellationToken cancellationToken)
    {
        if (_browser != null) return;

        await _browserLock.WaitAsync(cancellationToken);
        try
        {
            if (_browser != null) return;

            _playwright = await Playwright.CreateAsync();
            try
            {
                _browser = await _playwright.Chromium.LaunchAsync(new BrowserTypeLaunchOptions
                {
                    Headless = true,
                    Args = ["--disable-blink-features=AutomationControlled"],
                });
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Failed to launch browser, cleaning up Playwright instance");
                _playwright.Dispose();
                _playwright = null;
                throw;
            }
        }
        finally
        {
            _browserLock.Release();
        }
    }
}