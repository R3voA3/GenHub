using System;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Threading.Tasks;
using Avalonia.Media.Imaging;
using Avalonia.Platform;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using GenHub.Core.Models.Enums;
using GenHub.Core.Models.Results;
using GenHub.Core.Models.Results.Content;
using GenHub.Features.Downloads.Services;
using Microsoft.Extensions.Logging;

namespace GenHub.Features.Downloads.ViewModels;

/// <summary>
/// ViewModel for a content item displayed in the content grid.
/// </summary>
public partial class ContentGridItemViewModel : ObservableObject, IDisposable
{
    private static readonly HttpClient _imageClient = new()
    {
        Timeout = TimeSpan.FromSeconds(10),
    };

    private readonly ILogger<ContentGridItemViewModel>? _logger;
    private readonly System.Threading.CancellationTokenSource _cts = new();
    private bool _disposed;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanDownload))]
    [NotifyPropertyChangedFor(nameof(CanAddToProfile))]
    private bool _isDownloading;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(CanDownload))]
    [NotifyPropertyChangedFor(nameof(CanAddToProfile))]
    private bool _isDownloaded;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(ShowDownloadButton))]
    [NotifyPropertyChangedFor(nameof(ShowUpdateButton))]
    [NotifyPropertyChangedFor(nameof(ShowAddToProfileButton))]
    private ContentState _currentState = ContentState.NotDownloaded;

    [ObservableProperty]
    private int _downloadProgress;

    [ObservableProperty]
    private string _downloadStatus = string.Empty;

    [ObservableProperty]
    private bool _isSelected;

    [ObservableProperty]
    private Bitmap? _iconBitmap;

    /// <summary>
    /// Initializes a new instance of the <see cref="ContentGridItemViewModel"/> class with the specified search result and optional logger.
    /// </summary>
    /// <param name="searchResult">The content search result used to populate the view model; must not be null.</param>
    /// <param name="logger">The optional logger for this view model.</param>
    public ContentGridItemViewModel(ContentSearchResult searchResult, ILogger<ContentGridItemViewModel>? logger = null)
    {
        ArgumentNullException.ThrowIfNull(searchResult);
        SearchResult = searchResult;
        _logger = logger;

        // Start loading the icon asynchronously
        _ = LoadIconAsync();
    }

    /// <summary>
    /// Disposes task-related resources.
    /// </summary>
    public void Dispose()
    {
        if (!_disposed)
        {
            _cts.Cancel();
            _cts.Dispose();
            _disposed = true;
            GC.SuppressFinalize(this);
        }
    }

    /// <summary>
    /// Loads the content icon specified by <c>IconUrl</c> into <c>IconBitmap</c>, supporting local avares assets and remote HTTP URLs.
    /// </summary>
    /// <remarks>
    /// If loading fails for any reason, the method swallows the error and leaves <c>IconBitmap</c> unchanged so the UI can show a fallback.
    /// </remarks>
    private async Task LoadIconAsync()
    {
        if (string.IsNullOrEmpty(IconUrl)) return;

        try
        {
            if (IconUrl.StartsWith("avares://", StringComparison.OrdinalIgnoreCase))
            {
                var uri = new Uri(IconUrl);
                if (AssetLoader.Exists(uri))
                {
                    using var asset = AssetLoader.Open(uri);
                    IconBitmap = new Bitmap(asset);
                }
            }
            else
            {
                var bytes = await _imageClient.GetByteArrayAsync(IconUrl, _cts.Token);
                if (_cts.Token.IsCancellationRequested) return;

                using var stream = new MemoryStream(bytes);
                IconBitmap = new Bitmap(stream);
            }
        }
        catch (OperationCanceledException)
        {
            // Expected on disposal
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Failed to load icon for content {ContentName} from URL {IconUrl}", Name, IconUrl);
        }
    }

    /// <summary>
    /// Gets the underlying content search result.
    /// </summary>
    public ContentSearchResult SearchResult { get; }

    /// <summary>
    /// Gets the content ID.
    /// </summary>
    public string Id => SearchResult.Id ?? string.Empty;

    /// <summary>
    /// Gets the content name.
    /// </summary>
    public string Name => SearchResult.Name ?? "Unknown";

    /// <summary>
    /// Gets the content description.
    /// </summary>
    public string Description => SearchResult.Description ?? string.Empty;

    /// <summary>
    /// Gets the truncated description for card display.
    /// </summary>
    public string ShortDescription
    {
        get
        {
            if (string.IsNullOrEmpty(Description)) return string.Empty;
            var stringInfo = new System.Globalization.StringInfo(Description);
            return stringInfo.LengthInTextElements > 150
                ? stringInfo.SubstringByTextElements(0, 147) + "..."
                : Description;
        }
    }

    /// <summary>
    /// Gets the content version.
    /// </summary>
    public string Version => SearchResult.Version ?? string.Empty;

    /// <summary>
    /// Gets the author name.
    /// </summary>
    public string AuthorName => SearchResult.AuthorName ?? "Unknown";

    /// <summary>
    /// Gets a value indicating whether the author is known (not null/empty/Unknown).
    /// </summary>
    public bool HasAuthor => !string.IsNullOrEmpty(SearchResult.AuthorName) &&
                             !string.Equals(SearchResult.AuthorName, "Unknown", StringComparison.OrdinalIgnoreCase);

    /// <summary>
    /// Gets the content type.
    /// </summary>
    public ContentType ContentType => SearchResult.ContentType;

    /// <summary>
    /// Gets the content type display name.
    /// </summary>
    public string ContentTypeDisplay => ContentType.ToString();

    /// <summary>
    /// Gets the target game.
    /// </summary>
    public GameType TargetGame => SearchResult.TargetGame;

    /// <summary>
    /// Gets the provider name.
    /// </summary>
    public string ProviderName => SearchResult.ProviderName ?? string.Empty;

    /// <summary>
    /// Gets the icon URL for the content.
    /// </summary>
    public string? IconUrl => SearchResult.IconUrl;

    /// <summary>
    /// Gets the source URL for viewing more details.
    /// </summary>
    public string? SourceUrl => SearchResult.SourceUrl;

    /// <summary>
    /// Gets the last updated date (optional).
    /// </summary>
    public DateTime? LastUpdated => SearchResult.LastUpdated;

    /// <summary>
    /// Gets the formatted last updated string.
    /// </summary>
    public string LastUpdatedDisplay => LastUpdated?.ToString("MMM dd, yyyy") ?? "Unknown Date";

    /// <summary>
    /// Gets a value indicating whether the last updated date is visible.
    /// </summary>
    public bool IsLastUpdatedVisible => LastUpdated.HasValue;

    /// <summary>
    /// Gets a value indicating whether both author and date are visible (for separator).
    /// </summary>
    public bool HasAuthorAndDate => HasAuthor && IsLastUpdatedVisible;

    /// <summary>
    /// Gets the download size in bytes.
    /// </summary>
    public long DownloadSize => SearchResult.DownloadSize;

    /// <summary>
    /// Gets a value indicating whether the download size should be displayed (non-zero).
    /// </summary>
    public bool IsDownloadSizeVisible => DownloadSize > 0;

    /// <summary>
    /// Gets a value indicating whether the content can be downloaded.
    /// </summary>
    public bool CanDownload => !IsDownloaded && !IsDownloading && CurrentState != ContentState.Downloaded;

    /// <summary>
    /// Gets a value indicating whether the content can be added to a profile.
    /// </summary>
    public bool CanAddToProfile => IsDownloaded && !IsDownloading;

    /// <summary>
    /// Gets a value indicating whether the Download button should be shown.
    /// </summary>
    public bool ShowDownloadButton => CurrentState == ContentState.NotDownloaded;

    /// <summary>
    /// Gets a value indicating whether the Update button should be shown.
    /// </summary>
    public bool ShowUpdateButton => CurrentState == ContentState.UpdateAvailable;

    /// <summary>
    /// Gets a value indicating whether the Add to Profile button should be shown.
    /// </summary>
    public bool ShowAddToProfileButton => CurrentState == ContentState.Downloaded || CurrentState == ContentState.UpdateAvailable;

    /// <summary>
    /// Gets the tags associated with this content.
    /// </summary>
    public IList<string> Tags => SearchResult.Tags;

    /// <summary>
    /// Gets or sets the command to view details.
    /// Expected to be set by the parent view model to handle navigation or detail display.
    /// </summary>
    public System.Windows.Input.ICommand? ViewCommand { get; set; }

    /// <summary>
    /// Gets or sets the command to open the source URL.
    /// Expected to be set by the parent view model or a global service.
    /// </summary>
    public System.Windows.Input.ICommand? OpenUrlCommand { get; set; }

    /// <summary>
    /// Gets or sets the command to download the content.
    /// Expected to be set by the parent view model to handle the download workflow.
    /// </summary>
    public System.Windows.Input.ICommand? DownloadCommand { get; set; }

    /// <summary>
    /// Gets or sets the command to add content to a profile.
    /// Expected to be set by the parent view model to handle profile association.
    /// </summary>
    public System.Windows.Input.ICommand? AddToProfileCommand { get; set; }

    /// <summary>
    /// Gets or sets the command to update the content (download newer version).
    /// Expected to be set by the parent view model to handle the update workflow.
    /// </summary>
    public System.Windows.Input.ICommand? UpdateCommand { get; set; }

    /// <summary>
    /// Executes the configured view command, passing this view model as the command parameter.
    /// </summary>
    [RelayCommand]
    private void ViewDetails()
    {
        ViewCommand?.Execute(this);
    }

    /// <summary>
    /// Opens the item's source URL by invoking the bound OpenUrlCommand when a source URL is available.
    /// </summary>
    [RelayCommand]
    private void OpenSourceUrl()
    {
        if (!string.IsNullOrEmpty(SourceUrl))
        {
            OpenUrlCommand?.Execute(SourceUrl);
        }
    }

    /// <summary>
    /// Executes the configured DownloadCommand using this view model as the command parameter.
    /// </summary>
    [RelayCommand]
    private void DownloadContent()
    {
        DownloadCommand?.Execute(this);
    }

    /// <summary>
    /// Invokes the configured UpdateCommand, passing this view model as the command parameter if a command is set.
    /// </summary>
    [RelayCommand]
    private void UpdateContent()
    {
        UpdateCommand?.Execute(this);
    }

    /// <summary>
    /// Gets the collection of installable variants for this content.
    /// </summary>
    [ObservableProperty]
    private System.Collections.ObjectModel.ObservableCollection<InstallableVariant> _variants = [];

    /// <summary>
    /// Gets a value indicating whether this content has multiple variants.
    /// </summary>
    public bool HasVariants => Variants.Count > 0;

    partial void OnVariantsChanged(System.Collections.ObjectModel.ObservableCollection<InstallableVariant>? oldValue, System.Collections.ObjectModel.ObservableCollection<InstallableVariant> newValue)
    {
        if (oldValue != null)
        {
             oldValue.CollectionChanged -= Variants_CollectionChanged;
        }

        if (newValue != null)
        {
            newValue.CollectionChanged += Variants_CollectionChanged;
        }
    }

    private void Variants_CollectionChanged(object? sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
    {
        OnPropertyChanged(nameof(HasVariants));
    }
}